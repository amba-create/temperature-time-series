---
title: "Time Series Analysis"
author: "Amba Sharma"
date: "2025-04-11"
output: html_document
---

**Graph of maximal temperatures**

```{r}
library(readxl)
weather <- read_excel("~/Documents/year-two/survival-models /report /weather.xlsx", sheet = "forecasting")
head(weather)



#Create time series from highest column 
hightemp <- ts(weather$highest, start = c(2014,1), frequency = 12)
plot(hightemp,
     main = "Monthly Maximal Temperature in Rome",
     ylab ="Temperature in degrees",
     xlab = "Year")
```

Shows clear repeated seasons - peaks around mid-year (summer), troughs at the start and end (winter) Regular cycles roughly every 12 months =\> strong seasonality no obvious long term up or down

**Calculate and plot Highest ACF**

```{r}
acf(hightemp, lag.max = 24, main = "ACF of Maximal Temperatures")
```

Calculated the autocorrelation for up to 24 months

Vertical lines show the strength of correlation at each lag blue dashed lines are 95% confidence bounds (outside = significant)

Strong positive autocorrelation at lag one 0.79 ( confirms excel version )

A major spike at lag \~ 12 - strong yearly seasonality

Many lags are above the significance line (blue) especially lags like 1,2, 12

Suggests both short term memory and strong seasonal effects

**Get Highest ACF Values Numerically**

```{r}

acfresults <- acf(hightemp, lag.max = 24, plot = FALSE)
acfresults
```

Lag one = 0.788 =\> very high, strong month to month correlation

Lag 12 = 0.661 =\> strong, seasonal repeat

Some negative lags eg 5-9 which may reflect how temperatures drop between seasons

**Plot Highest PACF**

```{r}

pacf(hightemp, lag.max = 24, main = "PACF of Maximal Temperatures")
```

A strong spike at lag one then most values fall within the confidence bounds

Means that AR(1) model could explain much of the autocorrelation

The fact that later PACF lags are small suggests no need for many AR terms (1,2 is enough)

Overall - no clear long term term, strong 12 month seasonality, short term memory is strong, model suggestion is likely a seasonal ARIMA

**Model and forecast of SARIMA model of Highest Temperature:**

```{r}
library(forecast)
fit <- auto.arima(hightemp, seasonal = TRUE)

summary(fit)
forecasthighest <- forecast(fit, h =24)
plot (forecasthighest)
```

**Comparing results:**

```{r}
library(readxl)
weather <- read_excel("~/Documents/year-two/survival-models /report /weather.xlsx", sheet = "actual")
head(weather)

#Create time series from highest column 
hightemp2 <- ts(weather$highest, start = c(2014,1), frequency = 12)
plot(hightemp2,
     main = "Monthly Maximal Temperature in Rome 2014 - 2024",
     ylab ="Temperature in degrees",
     xlab = "Year")

#Comparing the graphs 
accuracy(forecasthighest,hightemp2)



```

ME - low bias (ideally 0)

RMSE - forecasting is quite accurate

(lower is better) MAE - low average error

MAPE - good (want less than 10% to show its strong - 0.0531 and 0.0495)

MASE - less than one

Thneils U - less than one

Both on training and and test data the model performs very well

MAPE is less than 5% - indicates strong accuracy

MASE and Theils U confirms forecasts are better than naive model

```{r}
#check residuals 
checkresiduals(fit)
```

Ljung Box test:

tests whether there is autocorrelation in the residuals

p\>0.05 =\> fail to reject Ho as residuals are not significantly autocorrelated

residuals behave like white noise (this is what we want)

The Ljung-Box test produced a p-value of 0.9628, indicating no significant autocorrelation in the residuals. This confirms that the model has adequately captured the structure of the series.

Residual diagnostic from ARIMA model:

Non seasonal part: -AR = 0, I=0, MA =\> no regular ARIMA terms

Seasonal part -AR = 1, I = 1, MA = 1, with seasonality of 12 months

Model is fully seasonal meaning it's relying only on yearly cycles to make predictions

Interpretation of Diagnostic Plots:

Residuals should look like random white noise - no trend, no seasonality, no clustering

My plot shows reasonable randomness though some clustering and outliers around 2019- 2020 are visible

Model could be improved

Bottom left plot: ACF Residual

All bars should stay within the blue lines (95% confidence bounds)

A few spikes are just touching the bounds (especially at lag 12,24, 36 ) =\> these may reflect remaining seasonality not fully captured

Suggest model did not completely remove autocorrelation - not good

Bottom Right Plot: Histogram of Residual + Normal Curve Checking

If residuals are normally distributed

Roughly bell shaped: - slight positive skew - long tail to the right - slight excess kurtosis (high center peak) - not perfectly normal

```{r}
auto.arima(hightemp, seasonal =TRUE)
```

sar(seasonal AR) : -0.1902

smar1(seasonal MA): -0.7528

values are within normal bounds (between -1 and 1) suggests stable model

residual variance (sigma squared) - lower is better

AIC/BIC - used to compare alternative models - lower values indicate a better fit

**Creating lowest temperature graph:**

```{r}
library(readxl)
weather <- read_excel("~/Documents/year-two/survival-models /report /weather.xlsx", sheet = "forecasting")
head(weather)

#Create time series from highest column 
lowtemp <- ts(weather$lowest, start = c(2014,1), frequency = 12)
plot(lowtemp,
     main = "Monthly Minimal Temperature in Rome",
     ylab ="Temperature in degrees",
     xlab = "Year")
```

Shows clear seasonality - consistent dips each winter and rises each summer

No obvious long term trend, just reoccurring annual cycles

Overall structure is similar to high temperature plot but with a lower range and slightly more noise

**Calculate and plot ACF**

```{r}
acf(lowtemp, lag.max = 24, main = "ACF of Minimal Temperatures")
```

Strong positive autocorrelation at lag 1,2, and especially at lag 12 (seasonal = 12 months )

Lags between 4-9 show negative autocorrelation which may reflect the mid season transition eg summer and winter

Confirms the presence of both short term dependence and seasonality

**Get ACF Values Numerically**

```{r}

acfresults2 <- acf(lowtemp, lag.max = 24, plot = FALSE)
acfresults2

```

Strong positive autocorrelation at lag 1,2 and especially at lag 12 ( seasonal = 12 months)

Lags between 4-9 shows negative autocorrelation which may reflect the mid-season transition eg summer and winter confirms the presence of both short term dependence and seasonality

**Plot PACF**

```{r}

pacf(lowtemp, lag.max = 24, main = "PACF of Minimal Temperatures")
```

Large spike at lag 1 strong AR(1)

Some additional small spikes at higher lags (eg around 9-10) but most fall within the confidence bounds Suggests that the non seasonal AR component is likely AR(1)

**Model and forecast of SARIMA model**

```{r}
library(forecast)
fit2 <- auto.arima(lowtemp, seasonal = TRUE)

summary(fit2)
```

All coefficients are in bounds (-1,1) and appear to be stable and statistically reasonable based on their standard error

MAPE shows Inf - usually happens when some actual values are below zero or zero - omit this result

Low autocorrelation in residuals

Shows seasonal structure well (with D = 1 and seasonal terms)

```{r}
forecastlowest <- forecast(fit2, h =24)
plot (forecastlowest)
```

**Comparing results:**

```{r}
library(readxl)
weather <- read_excel("~/Documents/year-two/survival-models /report /weather.xlsx", sheet = "actual")
head(weather)

#Create time series from highest column 
lowtemp2 <- ts(weather$lowest, start = c(2014,1), frequency = 12)
plot(lowtemp2,
     main = "Monthly Minimal temperature in Rome 2014 - 2024",
     ylab ="Temperature in degrees",
     xlab = "Year")

#Comparing the graphs 
accuracy(forecastlowest, lowtemp2)
```







```{r}
#check residuals 
checkresiduals(fit2)
```

Ljung Box test (model diagnostics):

pvalue less than 0.05 fail to reject the null hypothesis means residuals are not autocorrelated

Passes diagnostic testing

The Ljung-Box test (Q\* = 14.52, p = 0.4863) confirmed that the residuals show no significant autocorrelation, validating the model fit

Top Graph: Residual over Time

Black line shows how well model fits the data over time( A flat random cloud of points around zero is what you want)

My data: has no trend, some larger spikes, but no systematic patterns, one major outlier around 2021- 2022

Bottom Left: ACF of Residuals

Shows whether the residuals are autocorrelated (they shouldnt be)

Most bars are well within the blue dashed bounds 95% confidence interval

My model successfully removed autocorrelation from the series

This means my model captures the key patterns and structure in the original data

Bottom Right: Whether my residuals are normally distributed

Key assumption in time series modelling for confidence intervals and inferenc

Histogram is fairly bell shapede

Slightly skew right and some heavier tails than ideal but very typical for climate/ seasonal data

Orange line = normal curve data roughly follows

```{r}
auto.arima(lowtemp, seasonal =TRUE)
```

ME - low bias in training, higher bias in test

RSME - errors nearly double in test set

MAE - errors increase out of sample

MAPE - no usable

MASE - good in training (less than one) but slightly worse than naive in test

ACF1 - little autocorrection left in residuals

Theils - unusual result - zero division error

Model fits well in training - low RMSE MAE and MASE\<1

Test set - performance decreases (normal but worth noting)

MAPE - infinite - low temps are near 0 - cant divide by 0

RMSE and MAE - reasonable and residuals well behaved

The SARIMA(2,0,2)(2,1,1)[12] model fit the training data well, with RMSE = 1.92 and MASE = 0.61. Test set errors were slightly higher (RMSE = 2.93, MASE = 1.03), indicating some generalisation loss. The Ljung-Box test (p = 0.4863) confirmed the residuals were uncorrelated, supporting model adequacy. MAPE could not be evaluated due to near-zero actual values in the test set

**Augmented Dickey Fuller test**

To show if the time series is stationary ie has no trend or seasonality

```{r}
library (tseries)
adf.test(hightemp)
adf.test(lowtemp)


#applying seasonal differencing 
tempdiff <- diff(hightemp, lag = 12)
adf.test(tempdiff)

tempdiff2 <- diff(lowtemp, lag = 12)
adf.test(tempdiff2)
```

The Augmented Dickey-Fuller test was applied to both the original and seasonally differenced series. In all cases, the p-value was below 0.01, indicating that the null hypothesis of non-stationarity can be rejected. This confirms that the series are stationary, especially after seasonal differencing with a lag of 12, aligning with our earlier visual and ACF/PACF checks.



```{r}
# Load required libraries
library(forecast)
library(ggplot2)
library(dplyr)
library(tidyr)

# The error "arguments imply differing number of rows: 10, 24, 1" indicates
# that your time_forecast variable has 10 values, forecasthighest$mean has 24 values,
# and another variable has 1 value. Let's fix these mismatches.

# Assuming these objects already exist:
# hightemp - time series for training data (2014-2022)
# hightemp2 - time series for complete data (2014-2024)
# forecasthighest - forecast object from auto.arima for 2023-2024

# Extract the time information
time_forecast <- time(forecasthighest)
time_actual <- time(hightemp2)

# Print lengths to identify the issue
cat("Length of time_forecast:", length(time_forecast), "\n")
cat("Length of forecasthighest$mean:", length(forecasthighest$mean), "\n")
cat("Length of time_actual:", length(time_actual), "\n")
cat("Length of hightemp2:", length(hightemp2), "\n")
cat("Length of hightemp:", length(hightemp), "\n")

# Create data frame for actual data
df_actual <- data.frame(
  time = time_actual,
  temperature = as.numeric(hightemp2),
  type = "Actual"
)

# For historical data up to 2022
historical_end <- length(hightemp)
df_historical <- data.frame(
  time = time_actual[1:historical_end],
  temperature = as.numeric(hightemp),
  type = "Historical"
)

# For forecast part (2023-2024)
# Make sure all vectors have the same length
forecast_length <- length(forecasthighest$mean)
# If time_forecast doesn't have correct length, create a proper sequence
if(length(time_forecast) != forecast_length) {
  # Calculate the starting point for forecast (immediately after historical data)
  last_historical_time <- max(time_actual[1:historical_end])
  # Create sequence of times for forecast period
  time_forecast <- seq(from = last_historical_time + 1/12, 
                       by = 1/12, 
                       length.out = forecast_length)
}

df_forecast <- data.frame(
  time = time_forecast,
  temperature = as.numeric(forecasthighest$mean),
  type = "Forecast",
  lower80 = as.numeric(forecasthighest$lower[,1]),
  upper80 = as.numeric(forecasthighest$upper[,1]),
  lower95 = as.numeric(forecasthighest$lower[,2]),
  upper95 = as.numeric(forecasthighest$upper[,2])
)

# Combine all data
df_combined <- rbind(
  df_historical[, c("time", "temperature", "type")],
  df_forecast[, c("time", "temperature", "type")],
  df_actual[, c("time", "temperature", "type")]
)

# Create the combined plot
p <- ggplot() +
  # Add historical data
  geom_line(data = df_historical, 
            aes(x = time, y = temperature, color = type),
            size = 0.8) +
  
  # Add forecast with confidence intervals
  geom_ribbon(data = df_forecast,
              aes(x = time, ymin = lower95, ymax = upper95),
              fill = "lightblue", alpha = 0.3) +
  geom_ribbon(data = df_forecast,
              aes(x = time, ymin = lower80, ymax = upper80),
              fill = "lightblue", alpha = 0.5) +
  geom_line(data = df_forecast,
            aes(x = time, y = temperature, color = type),
            size = 1) +
  
  # Add actual data for 2023-2024 for comparison
  geom_line(data = df_actual[df_actual$time >= min(df_forecast$time),],
            aes(x = time, y = temperature, color = type),
            size = 1, linetype = "solid") +
  
  # Customize colors and labels
  scale_color_manual(values = c("Historical" = "gray", 
                                "Forecast" = "blue", 
                                "Actual" = "red"),
                     name = "Data Type") +
  
  # Add titles and labels
  labs(title = "Monthly Maximal Temperature in Rome: Forecast vs Actual",
       subtitle = "Comparison between ARIMA(0,0,0)(1,1,1)[12] forecast and actual values",
       x = "Year",
       y = "Temperature (째C)") +
  
  # Add a vertical line to separate historical data and forecast
  geom_vline(xintercept = max(df_historical$time), 
             linetype = "dashed", color = "darkgray") +
  
  # Customize the theme
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold"),
        axis.title = element_text(face = "bold"))

# Display the plot
print(p)

# Save the plot if needed
ggsave("maximal_temperature_comparison.png", p, width = 10, height = 6, dpi = 300)

# If you want a more focused plot showing just 2023-2024 comparison:
p_focused <- ggplot() +
  # Add forecast with confidence intervals
  geom_ribbon(data = df_forecast,
              aes(x = time, ymin = lower95, ymax = upper95),
              fill = "lightblue", alpha = 0.3) +
  geom_ribbon(data = df_forecast,
              aes(x = time, ymin = lower80, ymax = upper80),
              fill = "lightblue", alpha = 0.5) +
  geom_line(data = df_forecast,
            aes(x = time, y = temperature, color = type),
            size = 1) +
  
  # Add actual data for 2023-2024 for comparison
  geom_line(data = df_actual[df_actual$time >= min(df_forecast$time),],
            aes(x = time, y = temperature, color = type),
            size = 1) +
  
  # Customize colors and labels
  scale_color_manual(values = c("Forecast" = "blue", 
                                "Actual" = "red"),
                     name = "Data Type") +
  
  # Add titles and labels
  labs(title = "2023-2024 Maximal Temperature in Rome: Forecast vs Actual",
       subtitle = "Detailed comparison of forecast performance",
       x = "Year",
       y = "Temperature (째C)") +
  
  # Customize the theme
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold"),
        axis.title = element_text(face = "bold"))

# Display the focused plot
print(p_focused)

# Save the focused plot if needed
ggsave("maximal_temperature_comparison_2023_2024.png", p_focused, width = 8, height = 5, dpi = 300)
```
```{r}
# Load required libraries
library(forecast)
library(ggplot2)
library(dplyr)
library(tidyr)

# Load required libraries
library(forecast)
library(ggplot2)
library(dplyr)

# This is a simplified version that works around time series indexing issues
# and ensures all vectors have the same length

# Step 1: Extract data from your time series objects
# Historical data
historical_values <- as.numeric(lowtemp)
historical_dates <- time(lowtemp)

# Forecast data
forecast_values <- as.numeric(forecastlowest$mean)
forecast_lower80 <- as.numeric(forecastlowest$lower[,1])
forecast_upper80 <- as.numeric(forecastlowest$upper[,1]) 
forecast_lower95 <- as.numeric(forecastlowest$lower[,2])
forecast_upper95 <- as.numeric(forecastlowest$upper[,2])

# Create proper forecast dates
forecast_length <- length(forecast_values)
last_historical_date <- max(historical_dates)
forecast_dates <- seq(from = last_historical_date + 1/12, 
                      by = 1/12, 
                      length.out = forecast_length)

# Actual data (complete series)
actual_values <- as.numeric(lowtemp2)
actual_dates <- time(lowtemp2)

# Step 2: Create data frames for plotting
# Historical data
df_historical <- data.frame(
  date = historical_dates,
  temperature = historical_values,
  type = "Historical"
)

# Forecast data
df_forecast <- data.frame(
  date = forecast_dates,
  temperature = forecast_values,
  lower80 = forecast_lower80,
  upper80 = forecast_upper80,
  lower95 = forecast_lower95,
  upper95 = forecast_upper95,
  type = "Forecast"
)

# Find the index where forecast period starts in actual data
forecast_start_idx <- which(actual_dates >= min(forecast_dates))[1]
# If the index is found, extract the actual data for the forecast period
if (!is.na(forecast_start_idx)) {
  df_actual_forecast_period <- data.frame(
    date = actual_dates[forecast_start_idx:length(actual_dates)],
    temperature = actual_values[forecast_start_idx:length(actual_values)],
    type = "Actual"
  )
} else {
  # If no matching dates are found, create an empty data frame
  df_actual_forecast_period <- data.frame(
    date = numeric(0),
    temperature = numeric(0),
    type = character(0)
  )
  warning("No actual data found for the forecast period")
}

# Step 3: Create the plot
p <- ggplot() +
  # Add historical data
  geom_line(data = df_historical, 
            aes(x = date, y = temperature, color = type),
            size = 0.8) +
  
  # Add forecast with confidence intervals
  geom_ribbon(data = df_forecast,
              aes(x = date, ymin = lower95, ymax = upper95),
              fill = "lightblue", alpha = 0.3) +
  geom_ribbon(data = df_forecast,
              aes(x = date, ymin = lower80, ymax = upper80),
              fill = "lightblue", alpha = 0.5) +
  geom_line(data = df_forecast,
            aes(x = date, y = temperature, color = type),
            size = 1) +
  
  # Add actual data for the forecast period
  geom_line(data = df_actual_forecast_period,
            aes(x = date, y = temperature, color = type),
            size = 1) +
  
  # Add a vertical line to separate historical data and forecast
  geom_vline(xintercept = max(df_historical$date), 
             linetype = "dashed", color = "darkgray") +
  
  # Customize colors and labels
  scale_color_manual(values = c("Historical" = "gray", 
                                "Forecast" = "blue", 
                                "Actual" = "red"),
                     name = "Data Type") +
  
  # Add titles and labels
  labs(title = "Monthly Minimal Temperature in Rome: Forecast vs Actual",
       subtitle = "Comparison between ARIMA(2,0,2)(2,1,1)[12] forecast and actual values",
       x = "Year",
       y = "Temperature (째C)") +
  
  # Customize the theme
  theme_minimal() +
  theme(
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(face = "bold")
  )

# Print the plot
print(p)

# Save the plot
ggsave("minimal_temperature_comparison.png", p, width = 10, height = 6, dpi = 300)




```

```{r}
# Print the lengths to understand what's happening
print("Checking vector lengths:")
print(paste("Length of forecast_dates:", length(forecast_dates)))
print(paste("Length of forecast_values:", length(forecast_values)))
print(paste("Length of forecastlowest$lower[,1]:", length(forecastlowest$lower[,1])))
print(paste("Length of forecastlowest$upper[,1]:", length(forecastlowest$upper[,1])))

# The key issue is that forecast_dates only has 10 values but forecast_values has 24
# Let's create a proper time sequence for forecasts

# First, determine the correct length to use (use the forecast values length)
forecast_length <- length(forecast_values)

# Then create a proper date sequence starting from January 2023
# This ensures we have exactly the right number of dates
forecast_dates_fixed <- seq(from = 2023, by = 1/12, length.out = forecast_length)

# Now create the data frame with vectors of equal length
df_forecast <- data.frame(
  date = forecast_dates_fixed,
  temp = forecast_values,
  type = "Forecast",
  lower80 = forecastlowest$lower[,1],
  upper80 = forecastlowest$upper[,1]
)

# Find where 2023 starts in the actual data
year_2023_start <- which(actual_dates >= 2023)[1]

# For actual data, use a simple approach
df_actual <- data.frame(
  date = actual_dates[year_2023_start:length(actual_dates)],
  temp = actual_values[year_2023_start:length(actual_values)],
  type = "Actual"
)

# Create the comparison plot
ggplot() +
  # Add forecast with confidence intervals
  geom_ribbon(data = df_forecast,
              aes(x = date, ymin = lower80, ymax = upper80),
              fill = "lightblue", alpha = 0.5) +
  geom_line(data = df_forecast,
            aes(x = date, y = temp, color = type),
            size = 1) +
  # Add actual data
  geom_line(data = df_actual,
            aes(x = date, y = temp, color = type),
            size = 1) +
  # Customize colors
  scale_color_manual(values = c("Forecast" = "blue", "Actual" = "red")) +
  # Add labels
  labs(title = "Monthly Minimal Temperature in Rome: Forecast vs Actual (2023-2024)",
       x = "Year",
       y = "Temperature (째C)",
       color = "Data Type") +
  theme_minimal()
```



